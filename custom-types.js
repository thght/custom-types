// Generated by CoffeeScript 2.0.0-beta2
(function() {
  var RESERVED, types,
    hasProp = {}.hasOwnProperty,
    indexOf = [].indexOf;

  types = require('types.js');

  RESERVED = ['SET', 'GET', 'LOCK', 'UNLOCK', 'IS_LOCKED', 'LOCKED', '_KEYS'];

  types.create = function(id, model) {
    var CustomType, key, value;
    if (types.isString(id)) {
      model = types.forceObject(model);
    } else {
      model = types.forceObject(id);
    }
    id = types.forceString(id);
    CustomType = (function() {
      class CustomType {
        static getModel() {
          var copy, key, ref, value;
          copy = {};
          ref = CustomType._model;
          for (key in ref) {
            if (!hasProp.call(ref, key)) continue;
            value = ref[key];
            copy[key] = value;
          }
          return copy;
        }

        static has(key) {
          return CustomType._model.hasOwnProperty(key);
        }

        static showError(text) {
          return console.log(id + ': error! - ' + types.forceString(text));
        }

        static _isValidType(key, value) {
          if ((types.typeof(value)) === CustomType._types[key]) {
            return true;
          }
          return CustomType.showError(' cannot apply the ' + types.typeof(value) + ' type value: ' + value + ' to field "' + key + '", the value should be of type ' + CustomType._types[key]);
        }

        static _addGetSet(key) {
          if (!this[key]) {
            return Object.defineProperty(this, key, {
              set: (value) => {
                return this.SET(key, value);
              },
              get: () => {
                return this._KEYS[key];
              }
            });
          }
        }

        constructor(object) {
          var key, ref, value;
          object = types.forceObject(object);
          this._KEYS = {};
          this.LOCKED = [];
          ref = types.forceObject(CustomType._model);
          for (key in ref) {
            value = ref[key];
            CustomType._addGetSet.call(this, key, value);
            if ((object.hasOwnProperty(key)) && (CustomType._isValidType(key, object[key]))) {
              this.SET(key, object[key]);
            } else {
              this._KEYS[key] = value;
            }
          }
        }

        IS_LOCKED(key) {
          return !!~this.LOCKED.indexOf(key);
        }

        LOCK(...keys) {
          var i, key, len, ref, results;
          ref = types.intoArray(keys);
          results = [];
          for (i = 0, len = ref.length; i < len; i++) {
            key = ref[i];
            if (CustomType.has(key)) {
              results.push(this.LOCKED.push(key));
            } else {
              results.push(void 0);
            }
          }
          return results;
        }

        UNLOCK(...keys) {
          var i, index, key, len, ref, results;
          ref = types.intoArray(keys);
          results = [];
          for (i = 0, len = ref.length; i < len; i++) {
            key = ref[i];
            if (CustomType.has(key)) {
              index = this.LOCKED.indexOf(key);
              results.push(this.LOCKED.splice(index, 1));
            } else {
              results.push(void 0);
            }
          }
          return results;
        }

        GET(...keys) {
          var i, key, len, object, ref;
          object = {};
          if (keys.length < 1) {
            keys = Object.keys(this._KEYS);
          }
          ref = types.intoArray(keys);
          for (i = 0, len = ref.length; i < len; i++) {
            key = ref[i];
            if (CustomType.has(key)) {
              object[key] = this._KEYS[key];
            } else {
              CustomType.showError('could not get: ' + key + ', it doesn\'t exist in the model!');
            }
          }
          return object;
        }

        SET(object, value) {
          var key, ref, results, setValue;
          setValue = (key, value) => {
            if (CustomType.has(key)) {
              if (this.IS_LOCKED(key)) {
                return CustomType.showError('cannot set field "' + key + '" to: "' + value + '", "' + key + '" is locked!');
              } else if (CustomType._isValidType(key, value)) {
                return this._KEYS[key] = value;
              }
            } else {
              return CustomType.showError('cannot set value for key: "' + key + '", it doesn\'t exist in the model!');
            }
          };
          if (types.isObject(object)) {
            ref = types.forceObject(object);
            results = [];
            for (key in ref) {
              if (!hasProp.call(ref, key)) continue;
              value = ref[key];
              results.push(setValue(key, value));
            }
            return results;
          } else if (types.isString(object)) {
            return setValue(object, value);
          }
        }

      };

      CustomType.id = id;

      CustomType._types = {};

      CustomType._model = {};

      return CustomType;

    })();
    for (key in model) {
      if (!hasProp.call(model, key)) continue;
      value = model[key];
      if (indexOf.call(RESERVED, key) >= 0) {
        CustomType.showError('"' + key + '" is a reserved word and cannot be used in a model');
        continue;
      }
      CustomType._types[key] = types.typeof(value);
      CustomType._model[key] = value;
    }
    return CustomType;
  };

  module.exports = types;

}).call(this);
